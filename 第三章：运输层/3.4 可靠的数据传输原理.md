# 3.4 可靠的数据传输原理

服务抽象: 数据经过可靠信道进行传输, 传输数据比特不会收到损坏或丢失, 数据按照顺序进行交付

## 3.4.1 构造可靠的数据传输协议

### 1. 经过完全可靠信道的可靠数据传输

不用执行任何操作, 因为信道就是可靠的

### 2. 经具有比特差错的可靠数据传输

假设不丢包, 分组按照顺序接收

使用自动重传请求协议(ARO)

**rdt2.0**

若接收方接收到正确的分组, 发送肯定确认(ACK); 否则发送否定确认(NAK), 发送方重传

ARO还要使用三种协议:

1. 差错检测
2. 接收方反馈
3. 重传

当发送方处于等待ACK/NAK的状态时, 不能发送新的分组, 这称为停等协议

**rdt2.1/rdt2.2**

当ACK和NAK出现差错时, 即发送方接收到模糊不清的NAK/ACK时, 发送方重发分组, 但此时接收方不知道再次接收的分组是新的还是重发的, 在发送端可以对分组进行编号, 用1个比特0/1交替发送分组

rdt2.1: 当接收到失序的分组, 接收方发送一个肯定确认, 如果收到受损的分组, 发送一个否定确认

rdt2.2: 若接收方对同一个分组发送了两次ACK(冗余ACK), 就知道接收方没有正确接收跟在被确认两次的分组后面的分组; 比如发送方希望接收到ACK1, 但连续两次接收到ACK0, 说明ACK1没有发送成功

### 3. 经具有比特差错的丢包信道的可靠数据传输

**rdt3.0**

也是通过重传机制, 但是基于时间的, 因此有几个计时器

1. 每次发送一个分组便启动一个计时器
2. 响应计时器中断
3. 终止计时器
4. 若发送方在计时器结束后没有收到接收方的确认则会重新发送

图: 书139页

## 3.4.2 流水线可靠数据传输协议

rdt3.0的性能问题:  停等协议

解决方法: 允许发送多个分组而无需等待确认, 这种技术称为流水线

可靠数据传输协议如何实现流水线:

1. 增加序号范围
2. 发送方和接收方不得不缓存多个分组, 发送方至少缓存已发送但未确认的分组
3. 解决流水线的差错恢复: 回退N步(GBN), 选择重传(SR)

## 3.4.3 回退N步协议(GBN)

允许发送方发送多个分组而无需等待确认, 但也受限于未确认 的分组数不能超过N

GBN发送方必须响应三种类型的事件:

1. 上层的调用
2. 收到一个ACK, 对序号为n的分组采取累计确认, 表明接受方已正确接收序号为n及之前的所有分组
3. 计时器超时, 重传当前分组及之后的所有分组, 分组数小于等于N

GBN接收方的操作:

1. 如果一个序号为n的分组 被正确接收, 并且按序, 则发送一个累计确认ACKn, 并将该分组数据部分都给上层, 既然n是按序接收的, 那么n之前的分组也都按序接收, 因此可以累计确认
2. 如果其中一个分组失序, 会丢弃后来接收的所有分组, 直到发送方重新发送未被接收的分组, 如发送0,1,2,3, 如果2被丢失, 但0, 1都被正确接收(发送方会发送4, 5), 但接收方收到3, 4, 5会丢弃并发送ACK1, 表示接收方已正确接收序号为0, 1的分组, 等待发送方的2超时, 发送方会重发2, 3, 4, 5

图: 书144页

## 3.4.4 选择重传协议(SR)

要解决的问题: 单个分组出错就引起GBN重传大量分组

SR 通过让发送方只发送那些被怀疑出错或丢失的分组, 接收方会缓存之后的分组, 直到正确的接收那个出错的分组之后, 连同缓存的分组交付给上层

但有一个问题, 发送方的窗口长度与接收方的窗口长度不能同步, 因此**在SR中, 窗口长度必须小于或等于序号空间大小的一半**

如果有些分组会长时间停留在网络中, 接收方收到这些分组就会出错, 因为这些序号正被当前的使用, 所以每个分组会有寿命, 超过寿命就会被网络丢弃

